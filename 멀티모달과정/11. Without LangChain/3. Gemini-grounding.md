
# 구글 검색으로 그라운딩

GoogleSearch()라는 검색 툴에 google_search라는 이름을 붙이고 이를 매개 변수로 하는 Tool의 객체를 생성한다. 그리고 그 Tool의 객체를 GenerateContentConfig의 tools 매개변수에 넣으면 검색을 할 때 GoogleSearch() 검색 툴로 검색을 한다.

```python
from google import genai

from google.genai import types

  

# Configure the client

client = genai.Client()

  

# Define the grounding tool

grounding_tool = types.Tool(google_search=types.GoogleSearch())

  

# Configure generation settings

config = types.GenerateContentConfig(tools=[grounding_tool])

  

# Make the request

response = client.models.generate_content(

    model="gemini-2.5-flash",

    contents="유로2024의 우승팀은?",

    config=config,

)

  

# Print the grounded response

print(response.text)
```


실행을 하면 생성형 AI는 다음과 같은 프로세스를 걸쳐서 응답을 하게 된다.
![[Pasted image 20250811173428.png]]







# 인용한 사이트를 같이 표기하기

```python
def add_citations(response):

    text = response.text

    supports = response.candidates[0].grounding_metadata.grounding_supports

    chunks = response.candidates[0].grounding_metadata.grounding_chunks

  

    # Sort supports by end_index in descending order to avoid shifting issues when inserting.

    sorted_supports = sorted(supports, key=lambda s: s.segment.end_index, reverse=True)

  

    for support in sorted_supports:

        end_index = support.segment.end_index

        if support.grounding_chunk_indices:

            # Create citation string like [1](link1)[2](link2)

            citation_links = []

            for i in support.grounding_chunk_indices:

                if i < len(chunks):

                    uri = chunks[i].web.uri

                    citation_links.append(f"[{i + 1}]({uri})")

  

            citation_string = ", ".join(citation_links)

            text = text[:end_index] + citation_string + text[end_index:]

  

    return text

  
  

# Assuming response with grounding metadata

text_with_citations = add_citations(response)

print(text_with_citations)
```


### 함수 분석: `add_citations(response)`

#### 1. 핵심 데이터 추출


```python
def add_citations(response):
    text = response.text
    supports = response.candidates[0].grounding_metadata.grounding_supports
    chunks = response.candidates[0].grounding_metadata.grounding_chunks
```

- **`text`**: Gemini가 생성한 원본 텍스트입니다.
    
- **`supports`**: `supports`는 `response` 텍스트의 **특정 구간(segment)**이 어떤 검색 결과(`chunks`)와 관련되어 있는지를 알려주는 정보들의 리스트입니다.
    
- **`chunks`**: `chunks`는 Google Search가 실제로 가져온 **검색 결과(사이트 링크와 내용)**들의 리스트입니다. `supports`의 정보는 이 `chunks`의 인덱스를 참조합니다.
    

#### 2. 삽입 위치를 위한 정렬


```python
# Sort supports by end_index in descending order to avoid shifting issues when inserting.
sorted_supports = sorted(supports, key=lambda s: s.segment.end_index, reverse=True)
```

- 이 부분이 가장 중요합니다. `sorted()` 함수를 사용해 `supports` 리스트를 정렬합니다.
    
- `lambda s: s.segment.end_index`는 정렬의 기준으로, 텍스트에서 인용된 부분의 **끝 위치(end_index)**를 사용합니다.
    
- `reverse=True`는 **내림차순**으로 정렬하라는 뜻입니다. 즉, 텍스트의 **맨 뒤에 있는 인용부터 먼저** 처리합니다. 이렇게 해야 앞에 인용을 삽입하며 텍스트 길이가 늘어나도, 뒤에 있는 인용 위치가 틀어지지 않습니다.
    

#### 3. 반복문과 삽입 로직


```python
for support in sorted_supports:
    end_index = support.segment.end_index
    if support.grounding_chunk_indices:
        citation_links = []
        for i in support.grounding_chunk_indices:
            if i < len(chunks):
                uri = chunks[i].web.uri
                citation_links.append(f"[{i + 1}]({uri})")
        citation_string = ", ".join(citation_links)
        text = text[:end_index] + citation_string + text[end_index:]
```

 **`for` 반복문 상세 분석**


```python
for support in sorted_supports:
```

- **뜻**: `sorted_supports` 리스트의 각 항목을 `support`라는 변수에 넣고 반복문을 시작합니다. `support` 변수에는 "텍스트의 어느 부분이 어느 검색 결과와 관련되어 있는지"에 대한 정보가 담겨 있습니다.
    


```python
    end_index = support.segment.end_index
```

- **뜻**: 현재 `support`가 가리키는 텍스트 구간의 **끝 위치(end_index)**를 가져옵니다. 예를 들어, "Gemini는 강력한 AI 모델입니다."라는 문장이 인용되었다면, "입니다." 뒤의 위치인 `14`를 가져옵니다.
    


```python
    if support.grounding_chunk_indices:
```

- **뜻**: 이 `support`가 실제로 **참조할 검색 결과가 있는지** 확인하는 조건문입니다. `grounding_chunk_indices`는 검색 결과의 인덱스 리스트인데, 이 리스트가 비어있지 않으면(즉, 내용이 있으면) 아래 코드를 실행합니다.
    


```python
        citation_links = []
```

- **뜻**: `[]`는 비어있는 리스트를 만듭니다. 하나의 `support`가 여러 개의 검색 결과를 참조할 수 있으므로, **링크들을 임시로 저장할 리스트**를 만드는 것입니다.
    


```python
        for i in support.grounding_chunk_indices:
```

- **뜻**: `support`가 참조하는 검색 결과들의 인덱스(예: `[0, 1]`)를 `i`라는 변수에 넣고 반복합니다.
    


```python
            if i < len(chunks):
                uri = chunks[i].web.uri
                citation_links.append(f"[{i + 1}]({uri})")
```

- **뜻**:
    
    - `if i < len(chunks)`: 혹시라도 인덱스가 범위를 벗어나지 않도록 하는 안전장치입니다.
        
    - `uri = chunks[i].web.uri`: 인덱스 `i`를 사용해 실제 검색 결과 목록(`chunks`)에서 해당 사이트의 URL(`uri`)을 가져옵니다.
        
    - `citation_links.append(...)`: 가져온 URL을 `f"[{i + 1}]({uri})"`와 같은 형태로 포맷팅하여 `citation_links` 리스트에 추가합니다. (사용자에게 1부터 시작하는 번호로 보여주기 위해 `i + 1`을 사용)
        


```python
        citation_string = ", ".join(citation_links)
```

- **뜻**: `citation_links` 리스트에 있는 모든 링크를 **하나의 문자열로 합칩니다.** `", ".join(...)`은 리스트의 각 요소를 `,` 로 연결해줍니다.
    


```python
        text = text[:end_index] + citation_string + text[end_index:]
```

- **뜻**: 이 코드가 인용을 삽입하는 최종 단계입니다.
    
    - `text[:end_index]`: 원본 텍스트를 `end_index` 바로 앞까지 자릅니다.
        
    - `citation_string`: 위에서 만든 인용문 문자열입니다.
        
    - `text[end_index:]`: `end_index`부터 원본 텍스트의 끝까지 자릅니다.
        
    - 이 세 부분을 `+`로 합쳐서 `end_index` 위치에 인용문이 삽입된 새로운 `text`를 만듭니다.
        
    - **참고**: 이 코드는 `end_index`가 뒤에서부터 오기 때문에, 앞부분의 인덱스에는 영향을 주지 않습니다.
---

### 요약

`add_citations` 함수는 단순히 링크를 추가하는 것이 아니라, 응답 텍스트와 검색 결과 데이터를 정교하게 연결한 뒤, **텍스트의 뒷부분부터 차례대로 링크를 삽입**하여 모든 인용이 정확한 위치에 표시되도록 하는 함수입니다.