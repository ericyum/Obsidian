# SQL (SQLAlchemy)

> [Structured Query Language (SQL)](https://en.wikipedia.org/wiki/SQL)은 프로그래밍에 사용되는 도메인 특화 언어로, 관계형 데이터베이스 관리 시스템(RDBMS)에서 데이터를 관리하거나 관계형 데이터 스트림 관리 시스템(RDSMS)에서 스트림 처리를 위해 설계되었습니다. 특히 엔티티와 변수 간의 관계를 포함하는 구조화된 데이터를 다루는 데 유용합니다.

> [SQLAlchemy](https://github.com/sqlalchemy/sqlalchemy)는 MIT 라이선스에 따라 배포되는 Python 프로그래밍 언어용 오픈 소스 `SQL` 툴킷이자 객체 관계 매퍼(ORM)입니다.

이 노트북에서는 `SQLAlchemy`가 지원하는 모든 데이터베이스에 채팅 기록을 저장할 수 있는 `SQLChatMessageHistory` 클래스에 대해 설명합니다.

`SQLite` 이외의 데이터베이스와 함께 사용하려면 해당 데이터베이스 드라이버를 설치해야 합니다.


```python
# API KEY를 환경변수로 관리하기 위한 설정 파일
from dotenv import load_dotenv

# API KEY 정보로드
load_dotenv()
```

```
True
```

## 사용방법

storage를 사용하려면 다음 2가지만 제공하면 됩니다:

1. `session_id` - 사용자 이름, 이메일, 채팅 ID 등과 같은 세션의 고유 식별자입니다.
    
2. `connection` - 데이터베이스 연결을 지정하는 문자열입니다. 이 문자열은 SQLAlchemy의 create_engine 함수에 전달됩니다.
    


```python
from langchain_community.chat_message_histories import SQLChatMessageHistory

# SQLChatMessageHistory 객체를 생성하고 세션 ID와 데이터베이스 연결 파일을 설정
chat_message_history = SQLChatMessageHistory(
    session_id="sql_history", connection="sqlite:///sqlite.db"
)
```


```python
chat_message_history.session_id
```

```
'sql_history'
```


```python
# 사용자 메시지를 추가합니다.
chat_message_history.add_user_message(
    "안녕? 만나서 반가워. 내 이름은 테디야. 나는 랭체인 개발자야. 앞으로 잘 부탁해!"
)
# AI 메시지를 추가합니다.
chat_message_history.add_ai_message("안녕 테디, 만나서 반가워. 나도 잘 부탁해!")
```

- 저장된 대화내용을 확인합니다. `chat_message_history.messages`
    


```python
# 채팅 메시지 기록의 메시지들
chat_message_history.messages
```

```
[HumanMessage(content='안녕? 만나서 반가워. 내 이름은 테디야. 나는 랭체인 개발자야. 앞으로 잘 부탁해!', additional_kwargs={}, response_metadata={}),
 AIMessage(content='안녕 테디, 만나서 반가워. 나도 잘 부탁해!', additional_kwargs={}, response_metadata={})]
```

## Chain 에 적용

우리는 이 메시지 기록 클래스를 [LCEL Runnables](https://wikidocs.net/235884) 와 쉽게 결합할 수 있습니다.

LangChain 대화 관리 시스템 실행 과정 (최종 요약) `RunnableWithMessageHistory`는 대화 기록을 관리하고, 이를 체인에 자동으로 연결하는 핵심적인 역할을 담당합니다. 이 모든 과정은 `invoke()` 함수 호출 한 번으로 시작됩니다.

1. **대화의 시작: `invoke()` 호출** `chain_with_history.invoke()` 함수가 호출되면, 두 가지 정보가 입력됩니다.
    
    - 현재 질문: `{"question": "..."}`
        
    - 대화 설정값: `{"configurable": {"user_id": "...", "conversation_id": "..."}}`
        
2. **설정값 추출: `RunnableWithMessageHistory`의 역할** `RunnableWithMessageHistory`는 애초에 그렇게 설계된 함수입니다. 입력된 `config` 딕셔너리에서 `configurable` 키를 찾고, `history_factory_config`에 정의된 키(`user_id`, `conversation_id`)를 기준으로 필요한 값을 정확하게 추출합니다. 덕분에 다른 입력값들과 섞일 염려가 없습니다.
    
3. **대화 기록 객체 반환: `get_chat_history` 실행** 추출된 `user_id`와 `conversation_id`가 `get_chat_history` 함수의 인자로 전달됩니다. 이 함수는 `SQLChatMessageHistory` 클래스의 **인스턴스(객체)**를 반환하며, 이는 DB 파일의 `user1` 테이블과 `conversation1` 세션에 해당하는 대화 기록을 관리합니다. 이 단계에서 DB에 테이블과 `session_id` 컬럼이 생성됩니다.
    
4. **프롬프트 구성: 입력값 및 대화 기록 준비** `RunnableWithMessageHistory`는 반환된 `SQLChatMessageHistory` 객체의 `messages` 속성을 호출하여 실제 대화 기록 리스트를 가져옵니다.
    
    - `input_messages_key="question"`에 따라 현재 질문이 프롬프트 입력값으로 준비됩니다.
        
    - `history_messages_key="chat_history"`에 따라, 가져온 대화 기록 리스트가 `chat_history`라는 키로 프롬프트에 주입될 준비를 마칩니다. 이때, `MessagesPlaceholder`는 메시지 객체 리스트를 모델이 이해하는 구조화된 형식으로 변환하는 중요한 역할을 수행합니다.
        
5. **최종 프롬프트 완성 및 실행** `ChatPromptTemplate`에서 `MessagesPlaceholder(variable_name="chat_history")`에는 준비된 대화 기록 리스트가, `("human", "{question}")`에는 사용자의 질문이 주입됩니다. 이렇게 완성된 프롬프트가 언어 모델(LLM)에 전달되어 답변을 생성합니다.
    
6. **대화 기록 저장 및 최종 반환값** LLM이 답변을 반환하면, `RunnableWithMessageHistory`는 '알아서' 현재의 질문과 답변을 `get_chat_history` 객체의 `save_context()` 메서드를 통해 DB에 저장합니다. 이 과정은 답변이 사용자에게 반환되기 직전에 이루어집니다.
    
    마지막으로, LLM의 답변이 `StrOutputParser()`에 의해 파싱된 후, `invoke()` 함수의 최종 반환값으로 출력됩니다.
    


```python
from langchain_core.prompts import (
    ChatPromptTemplate,
    MessagesPlaceholder,
)
from langchain_core.runnables.history import RunnableWithMessageHistory
from langchain_openai import ChatOpenAI
from langchain_core.output_parsers import StrOutputParser
```


```python
prompt = ChatPromptTemplate.from_messages(
    [
        # 시스템 메시지
        ("system", "You are a helpful assistant."),
        # 대화 기록을 위한 Placeholder
        MessagesPlaceholder(variable_name="chat_history"),
        ("human", "{question}"),  # 질문
    ]
)

# chain 을 생성합니다.
chain = prompt | ChatOpenAI(model_name="gpt-4.1-mini") | StrOutputParser()
```

`sqlite.db` 에서 대화내용을 가져오는 함수를 만듭니다.


```python
def get_chat_history(user_id, conversation_id):
    return SQLChatMessageHistory(
        table_name=user_id,
        session_id=conversation_id,
        connection="sqlite:///sqlite.db",
    )
```

`config_fields` 를 설정합니다. 이는 대화정보를 조회할 때 참고 정보로 활용합니다.

- `user_id`: 사용자 ID
    
- `conversation_id`: 대화 ID
    


```python
from langchain_core.runnables.utils import ConfigurableFieldSpec

config_fields = [
    ConfigurableFieldSpec(
        id="user_id",
        annotation=str,
        name="User ID",
        description="Unique identifier for a user.",
        default="",
        is_shared=True,
    ),
    ConfigurableFieldSpec(
        id="conversation_id",
        annotation=str,
        name="Conversation ID",
        description="Unique identifier for a conversation.",
        default="",
        is_shared=True,
    ),
]
```


```python
chain_with_history = RunnableWithMessageHistory(
    chain,
    get_chat_history,  # 대화 기록을 가져오는 함수를 설정합니다.
    input_messages_key="question",  # 입력 메시지의 키를 "question"으로 설정
    history_messages_key="chat_history",  # 대화 기록 메시지의 키를 "chat_history"로 설정
    history_factory_config=config_fields,  # 대화 기록 조회시 참고할 파라미터를 설정합니다.
)
```

- `"configurable"` 키 아래에 `"user_id"`, `"conversation_id"` key-value 쌍을 설정합니다.
    


```python
# config 설정
config = {"configurable": {"user_id": "user1", "conversation_id": "conversation1"}}
```

질문에 이름을 물어보는 질문을 해보겠습니다. 이전에 저장한 대화가 있다면, 올바르게 답할 것입니다.

- `chain_with_history` 객체의 `invoke` 메서드를 호출하여 질문에 대한 답변을 생성합니다.
    
- `invoke` 메서드에는 질문 딕셔너리와 `config` 설정이 전달됩니다.
    


```python
# 질문과 config 를 전달하여 실행합니다.
chain_with_history.invoke({"question": "안녕 반가워, 내 이름은 테디야"}, config)
```

```
'안녕 테디야! 반가워. 어떻게 도와줄까?'
```


```python
# 후속 질문을 실해합니다.
chain_with_history.invoke({"question": "내 이름이 뭐라고?"}, config)
```

```
'네 이름은 테디라고 했어! 무엇을 도와줄까?'
```

이번에는 같은 `user_id` 를 가지지만 `conversion_id` 가 다른 값을 가지도록 설정합니다.


```python
# config 설정
config = {"configurable": {"user_id": "user1", "conversation_id": "conversation2"}}

# 질문과 config 를 전달하여 실행합니다.
chain_with_history.invoke({"question": "내 이름이 뭐라고?"}, config)
```

```
'죄송하지만 사용자의 이름을 알 수 없습니다. 알려주시면 기억하겠습니다!'
```