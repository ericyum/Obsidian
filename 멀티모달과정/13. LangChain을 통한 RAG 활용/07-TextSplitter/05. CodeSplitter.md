# Split code

CodeTextSplitter를 사용하면 다양한 프로그래밍 언어로 작성된 코드를 분할할 수 있습니다.

이를 위해서는 `Language` enum을 import하고, 해당하는 프로그래밍 언어를 지정해주면 됩니다.

`RecursiveCharacterTextSplitter`를 사용하여 텍스트를 분할하는 예제입니다.

- `langchain_text_splitters` 모듈에서 `Language`와 `RecursiveCharacterTextSplitter` 클래스를 임포트합니다.
- `RecursiveCharacterTextSplitter`는 텍스트를 문자 단위로 재귀적으로 분할하는 텍스트 분할기입니다.

```python
from langchain_text_splitters import (
    Language,
    RecursiveCharacterTextSplitter,
)
```

지원되는 언어의 전체 목록을 가져옵니다.

```python
# 지원되는 언어의 전체 목록을 가져옵니다.
[e.value for e in Language]
```

**Output:**

```
['cpp',
 'go',
 'java',
 'kotlin',
 'js',
 'ts',
 'php',
 'proto',
 'python',
 'rst',
 'ruby',
 'rust',
 'scala',
 'swift',
 'markdown',
 'latex',
 'html',
 'sol',
 'csharp',
 'cobol',
 'c',
 'lua',
 'perl',
 'haskell',
 'elixir',
 'powershell',
 'visualbasic6']
```

`RecursiveCharacterTextSplitter` 클래스의 `get_separators_for_language` 메서드를 사용하여 특정 언어에 사용되는 구분자(separators)를 확인할 수 있습니다.

- 예시에서는 `Language.PYTHON` 열거형 값을 인자로 전달하여 Python 언어에 사용되는 구분자를 확인합니다.

```python
# 주어진 언어에 대해 사용되는 구분자를 확인할 수 있습니다.
RecursiveCharacterTextSplitter.get_separators_for_language(Language.PYTHON)
```

**Output:**

```
['\nclass ', '\ndef ', '\n\tdef ', '\n\n', '\n', ' ', '']
```

1. '\nclass ': 클래스 정의를 최상위 분할 단위로 봅니다. 새 클래스가 시작되는 지점에서 코드를 분할하여 각 클래스 정의를 별도의 덩어리로 만들려고 시도합니다. \n (줄바꿈)이 앞에 붙어 있어, 라인의 시작 부분에 나오는 클래스 선언을 정확히 찾아냅니다.  

2. '\ndef ': 함수 정의를 그 다음 분할 단위로 사용합니다. 클래스 내부가 아닌, 모듈 레벨에서 정의된 함수들을 분리하는 데 사용됩니다.  

3. '\n\tdef ': 클래스 내부에 정의된 메서드(메소드)를 분리합니다. \t (탭)은 들여쓰기를 의미하며, 이를 통해 클래스에 속한 메서드 정의를 식별합니다.  

4. '\n\n': 두 번의 줄바꿈을 기준으로 분할합니다. 파이썬에서는 보통 함수나 클래스 정의 사이, 또는 논리적으로 구분되는 코드 블록 사이에 빈 줄을 두는 경우가 많습니다. 이는 코드의 논리적 단락을 나누는 역할을 합니다.  
  
5. '\n': 단일 줄바꿈을 기준으로 분할합니다. 더 이상 위의 구조적인 분할이 불가능할 경우, 각 코드 라인을 개별적인 단위로 나누게 됩니다.  

6. ' ': 공백을 기준으로 분할합니다. 텍스트가 chunk_size를 초과하는 매우 긴 한 줄의 코드일 경우, 단어 단위로 분할을 시도합니다.  

7. '': 빈 문자열을 기준으로 분할합니다. 이는 최후의 수단으로, 어떤 구분자로도 더 이상 나눌 수 없는 상태에서 덩어리가 여전히 너무 크다면, 글자 단위로 강제 분할을 수행합니다.  

## Python

`RecursiveCharacterTextSplitter` 사용한 예제는 다음과 같습니다.

- `RecursiveCharacterTextSplitter`를 사용하여 Python 코드를 문서 단위로 분할합니다.
  - `language` 매개변수에 `Language.PYTHON`을 지정하여 Python 언어를 사용합니다.
  - `chunk_size`를 50으로 설정하여 각 문서의 최대 크기를 제한합니다.
  - `chunk_overlap`을 0으로 설정하여 문서 간의 중복을 허용하지 않습니다.

```python
PYTHON_CODE = """
def hello_world():
    print("Hello, World!")

hello_world()
"""

python_splitter = RecursiveCharacterTextSplitter.from_language(
    language=Language.PYTHON, chunk_size=50, chunk_overlap=0
)
```

`Document` 를 생성합니다. 생성된 `Document` 는 리스트 형태로 반환됩니다.

```python
python_docs = python_splitter.create_documents([PYTHON_CODE])
python_docs
```

**Output:**

```
[Document(metadata={}, page_content='def hello_world():\n    print("Hello, World!")'),
 Document(metadata={}, page_content='hello_world()')]
```

```python
for doc in python_docs:
    print(doc.page_content, end="\n==================\n")
```

**Output:**

```
def hello_world():
    print("Hello, World!")
==================
hello_world()
==================
```

## JS

다음은 JS 텍스트 분할기를 사용한 예시입니다

```python
JS_CODE = """
function helloWorld() {
  console.log("Hello, World!");
}

helloWorld();
"""

js_splitter = RecursiveCharacterTextSplitter.from_language(
    language=Language.JS, chunk_size=60, chunk_overlap=0
)

js_docs = js_splitter.create_documents([JS_CODE])
js_docs
```

**Output:**

```
[Document(metadata={}, page_content='function helloWorld() {\n  console.log("Hello, World!");\n}'),
 Document(metadata={}, page_content='helloWorld();')]
```

## TS

다음은 TS 텍스트 분할기를 사용한 예시입니다.

```python
TS_CODE = """
function helloWorld(): void {
  console.log("Hello, World!");
}

helloWorld();
"""

ts_splitter = RecursiveCharacterTextSplitter.from_language(
    language=Language.TS, chunk_size=60, chunk_overlap=0
)
ts_docs = ts_splitter.create_documents([TS_CODE])
ts_docs
```

**Output:**

```
[Document(metadata={}, page_content='function helloWorld(): void {'),
 Document(metadata={}, page_content='console.log("Hello, World!");\n}'),
 Document(metadata={}, page_content='helloWorld();')]
```

## Markdown

다음은 Markdown 텍스트 분할기를 사용한 예시입니다.

```python
markdown_text = """
# 🦜️🔗 LangChain

⚡ LLM을 활용한 초스피드 애플리케이션 구축 ⚡

## 빠른 설치

```bash
pip install langchain
```

# 빠르게 발전하는 분야의 오픈 소스 프로젝트 입니다. 많관부 🙏
"""
```

분할하고 결과를 출력합니다.

```python
md_splitter = RecursiveCharacterTextSplitter.from_language(
    # 마크다운 언어를 사용하여 텍스트 분할기 생성
    language=Language.MARKDOWN,
    # 청크 크기를 60으로 설정
    chunk_size=60,
    # 청크 간 중복되는 부분이 없도록 설정
    chunk_overlap=0,
)
# 마크다운 텍스트를 분할하여 문서 생성
md_docs = md_splitter.create_documents([markdown_text])
# 생성된 문서 출력
md_docs
```

**Output:**

```
[Document(metadata={}, page_content='# 🦜️🔗 LangChain\n\n⚡ LLM을 활용한 초스피드 애플리케이션 구축 ⚡'),
 Document(metadata={}, page_content='## 빠른 설치\n\n```bash\npip install langchain\n```'),
 Document(metadata={}, page_content='# 빠르게 발전하는 분야의 오픈 소스 프로젝트 입니다. 많관부 🙏')]
```

## Latex

LaTeX는 문서 작성을 위한 마크업 언어로, 수학 기호와 수식을 표현하는 데 널리 사용됩니다.

다음은 LaTeX 텍스트의 예시입니다.

```python
latex_text = """
\documentclass{article}

\begin{document}

\maketitle

\section{Introduction}
% LLM은 방대한 양의 텍스트 데이터로 학습하여 사람과 유사한 언어를 생성할 수 있는 기계 학습 모델의 한 유형입니다.
% 최근 몇 년 동안 LLM은 언어 번역, 텍스트 생성, 감성 분석 등 다양한 자연어 처리 작업에서 상당한 발전을 이루었습니다.

\subsection{History of LLMs}
% 초기 LLM은 1980년대와 1990년대에 개발되었지만, 처리할 수 있는 데이터 양과 당시 사용 가능한 컴퓨팅 능력으로 인해 제한되었습니다.
% 그러나 지난 10년 동안 하드웨어와 소프트웨어의 발전으로 대규모 데이터 세트에 대해 LLM을 학습시킬 수 있게 되었고, 이는 성능의 큰 향상으로 이어졌습니다.

\subsection{Applications of LLMs}
% LLM은 챗봇, 콘텐츠 생성, 가상 어시스턴트 등 산업 분야에서 많은 응용 분야를 가지고 있습니다.
% 또한 언어학, 심리학, 컴퓨터 언어학 연구를 위해 학계에서도 사용될 수 있습니다.

\end{document}
"""
```

분할하고 결과를 출력합니다.

```python
latex_splitter = RecursiveCharacterTextSplitter.from_language(
    # 마크다운 언어를 사용하여 텍스트를 분할합니다.
    language=Language.LATEX,
    # 각 청크의 크기를 60자로 설정합니다.
    chunk_size=60,
    # 청크 간의 중복되는 문자 수를 0으로 설정합니다.
    chunk_overlap=0,
)
# latex_text를 분할하여 문서 목록을 생성합니다.
latex_docs = latex_splitter.create_documents([latex_text])
# 생성된 문서 목록을 출력합니다.
latex_docs
```

**Output:**

```
[Document(metadata={}, page_content='\\documentclass{article}\n\n\begin{document}\n\n\maketitle'),
 Document(metadata={}, page_content='\section{Introduction}\n% LLM은 방대한 양의 텍스트 데이터로 학습하여 사람과 유사한'),
 Document(metadata={}, page_content='언어를 생성할 수 있는 기계 학습 모델의 한 유형입니다.\n% 최근 몇 년 동안 LLM은 언어 번역, 텍스트'),
 Document(metadata={}, page_content='생성, 감성 분석 등 다양한 자연어 처리 작업에서 상당한 발전을 이루었습니다.'),
 Document(metadata={}, page_content='\subsection{History of LLMs}\n% 초기 LLM은 1980년대와 1990년대에'),
 Document(metadata={}, page_content='개발되었지만, 처리할 수 있는 데이터 양과 당시 사용 가능한 컴퓨팅 능력으로 인해 제한되었습니다.\n%'),
 Document(metadata={}, page_content='그러나 지난 10년 동안 하드웨어와 소프트웨어의 발전으로 대규모 데이터 세트에 대해 LLM을 학습시킬 수'),
 Document(metadata={}, page_content='있게 되었고, 이는 성능의 큰 향상으로 이어졌습니다.'),
 Document(metadata={}, page_content='\subsection{Applications of LLMs}\n% LLM은 챗봇, 콘텐츠 생성, 가상'),
 Document(metadata={}, page_content='어시스턴트 등 산업 분야에서 많은 응용 분야를 가지고 있습니다.\n% 또한 언어학, 심리학, 컴퓨터 언어학'),
 Document(metadata={}, page_content='연구를 위해 학계에서도 사용될 수 있습니다.\n\n\end{document}')]
```

## HTML

HTML 텍스트 분할기를 사용한 예제는 다음과 같습니다.

```python
html_text = """
<!DOCTYPE html>
<html>
    <head>
        <title>🦜️🔗 LangChain</title>
        <style>
            body {
                font-family: Arial, sans-serif;  
            }
            h1 {
                color: darkblue;
            }
        </style>
    </head>
    <body>
        <div>
            <h1>🦜️🔗 LangChain</h1>
            <p>⚡ Building applications with LLMs through composability ⚡</p>  
        </div>
        <div>
            As an open-source project in a rapidly developing field, we are extremely open to contributions.
        </div>
    </body>
</html>
"""
```

분할하고 결과를 출력합니다.

```python
html_splitter = RecursiveCharacterTextSplitter.from_language(
    # HTML 언어를 사용하여 텍스트 분할기 생성
    language=Language.HTML,
    # 청크 크기를 60으로 설정
    chunk_size=60,
    # 청크 간 중복되는 부분이 없도록 설정
    chunk_overlap=0,
)
# 주어진 HTML 텍스트를 분할하여 문서 생성
html_docs = html_splitter.create_documents([html_text])
# 생성된 문서 출력
html_docs
```

**Output:**

```
[Document(metadata={}, page_content='<!DOCTYPE html>\n<html>'),
 Document(metadata={}, page_content='<head>\n        <title>🦜️🔗 LangChain</title>'),
 Document(metadata={}, page_content='<style>\n            body {\n                font-family: Aria'),
 Document(metadata={}, page_content='l, sans-serif;  \n            }\n            h1 {'),
 Document(metadata={}, page_content='color: darkblue;\n            }\n        </style>\n    </he'),
 Document(metadata={}, page_content='ad>'),
 Document(metadata={}, page_content='<body>'),
 Document(metadata={}, page_content='<div>\n            <h1>🦜️🔗 LangChain</h1>'),
 Document(metadata={}, page_content='<p>⚡ Building applications with LLMs through composability ⚡'),
 Document(metadata={}, page_content='</p>  \n        </div>'),
 Document(metadata={}, page_content='<div>\n            As an open-source project in a rapidly dev'),
 Document(metadata={}, page_content='eloping field, we are extremely open to contributions.'),
 Document(metadata={}, page_content='</div>\n    </body>\n</html>')]
```

```python
!pip install markdownify
```

**Output:**

```
Collecting markdownify
  Downloading markdownify-1.2.0-py3-none-any.whl.metadata (9.9 kB)
Requirement already satisfied: beautifulsoup4<5,>=4.9 in c:\users\sba\appdata\local\pypoetry\cache\virtualenvs\langchain-kr-us6bdj1p-py3.11\lib\site-packages (from markdownify) (4.13.4)
Requirement already satisfied: six<2,>=1.15 in c:\users\sba\appdata\local\pypoetry\cache\virtualenvs\langchain-kr-us6bdj1p-py3.11\lib\site-packages (from markdownify) (1.17.0)
Requirement already satisfied: soupsieve>1.2 in c:\users\sba\appdata\local\pypoetry\cache\virtualenvs\langchain-kr-us6bdj1p-py3.11\lib\site-packages (from beautifulsoup4<5,>=4.9->markdownify) (2.7)
Requirement already satisfied: typing-extensions>=4.0.0 in c:\users\sba\appdata\local\pypoetry\cache\virtualenvs\langchain-kr-us6bdj1p-py3.11\lib\site-packages (from beautifulsoup4<5,>=4.9->markdownify) (4.14.1)
Downloading markdownify-1.2.0-py3-none-any.whl (15 kB)
Installing collected packages: markdownify
Successfully installed markdownify-1.2.0
```

```python
# 필요한 라이브러리 설치
# pip install markdownify beautifulsoup4

from markdownify import markdownify as md
from bs4 import BeautifulSoup

# 1. 변환할 HTML 내용
html_content = """
<!DOCTYPE html>
<html>
<head>
    <title>HTML to Markdown 변환</title>
</head>
<body>
    <h1>LangChain과 RAG</h1>
    <p>RAG(Retrieval-Augmented Generation)는 외부 데이터를 활용하여 LLM의 답변을 보강하는 기술입니다. LLM의 한계를 보완하여 더 정확한 정보를 제공합니다.</p>
    <h2>주요 구성 요소</h2>
    <ul>
        <li>문서 로더 (Document Loaders)</li>
        <li>텍스트 분할기 (Text Splitters)</li>
        <li>임베딩 모델 (Embedding Models)</li>
        <li>벡터 저장소 (Vector Store)</li>
    </ul>
    <h3>파이프라인 단계</h3>
    <ol>
        <li>데이터 수집 및 전처리</li>
        <li>질문 검색 및 관련 정보 추출</li>
        <li>LLM을 통한 답변 생성</li>
    </ol>
</body>
</html>
"""

# 2. BeautifulSoup를 사용하여 HTML <title> 태그 추출 (선택 사항)
# HTML의 <head>에 있는 title을 변환 결과의 최상단 제목으로 사용하고 싶을 때 유용합니다.
soup = BeautifulSoup(html_content, "html.parser")
html_title = soup.title.string if soup.title else "제목 없음"
print(f"변환된 Markdown 제목: # {html_title}\n")


# 3. markdownify를 사용하여 HTML 본문을 마크다운으로 변환
# h1 -> #, h2 -> ##, p -> 단락, ul/li -> *, ol/li -> 1. 으로 변환
markdown_result = md(html_content)

# 4. 변환 결과 출력
print("--- 원본 HTML 내용 ---")
print(html_content)
print("\n" + "=" * 50 + "\n")
print("--- 마크다운 변환 결과 ---")
# 추출한 타이틀을 결과에 추가
final_markdown = f"# {html_title}\n\n" + markdown_result
print(final_markdown)
```

**Output:**

```
변환된 Markdown 제목: # HTML to Markdown 변환

--- 원본 HTML 내용 ---

<!DOCTYPE html>
<html>
<head>
    <title>HTML to Markdown 변환</title>
</head>
<body>
    <h1>LangChain과 RAG</h1>
    <p>RAG(Retrieval-Augmented Generation)는 외부 데이터를 활용하여 LLM의 답변을 보강하는 기술입니다. LLM의 한계를 보완하여 더 정확한 정보를 제공합니다.</p>
    <h2>주요 구성 요소</h2>
    <ul>
        <li>문서 로더 (Document Loaders)</li>
        <li>텍스트 분할기 (Text Splitters)</li>
        <li>임베딩 모델 (Embedding Models)</li>
        <li>벡터 저장소 (Vector Store)</li>
    </ul>
    <h3>파이프라인 단계</h3>
    <ol>
        <li>데이터 수집 및 전처리</li>
        <li>질문 검색 및 관련 정보 추출</li>
        <li>LLM을 통한 답변 생성</li>
    </ol>
</body>
</html>


==================================================

--- 마크다운 변환 결과 ---
# HTML to Markdown 변환

HTML to Markdown 변환


LangChain과 RAG
==============

RAG(Retrieval-Augmented Generation)는 외부 데이터를 활용하여 LLM의 답변을 보강하는 기술입니다. LLM의 한계를 보완하여 더 정확한 정보를 제공합니다.

주요 구성 요소
--------

* 문서 로더 (Document Loaders)
* 텍스트 분할기 (Text Splitters)
* 임베딩 모델 (Embedding Models)
* 벡터 저장소 (Vector Store)

### 파이프라인 단계

1. 데이터 수집 및 전처리
2. 질문 검색 및 관련 정보 추출
3. LLM을 통한 답변 생성
```

```python
print(final_markdown)
```

**Output:**

```
# HTML to Markdown 변환

HTML to Markdown 변환


LangChain과 RAG
==============

RAG(Retrieval-Augmented Generation)는 외부 데이터를 활용하여 LLM의 답변을 보강하는 기술입니다. LLM의 한계를 보완하여 더 정확한 정보를 제공합니다.

주요 구성 요소
--------

* 문서 로더 (Document Loaders)
* 텍스트 분할기 (Text Splitters)
* 임베딩 모델 (Embedding Models)
* 벡터 저장소 (Vector Store)

### 파이프라인 단계

1. 데이터 수집 및 전처리
2. 질문 검색 및 관련 정보 추출
3. LLM을 통한 답변 생성
```

## Solidity

Solidity 텍스트 분할기를 사용한 예제는 다음과 같습니다:

- Solidity 코드를 문자열 형태로 `SOL_CODE` 변수에 저장합니다.
- `RecursiveCharacterTextSplitter`를 사용하여 Solidity 코드를 청크 단위로 분할하는 `sol_splitter`를 생성합니다.
  - `language` 매개변수를 `Language.SOL`로 설정하여 Solidity 언어를 지정합니다.
  - `chunk_size`를 128로 설정하여 각 청크의 최대 크기를 지정합니다.
  - `chunk_overlap`을 0으로 설정하여 청크 간의 중복을 없앱니다.
- `sol_splitter.create_documents()` 메서드를 사용하여 `SOL_CODE`를 청크 단위로 분할하고, 분할된 청크를 `sol_docs` 변수에 저장합니다.
- `sol_docs`를 출력하여 분할된 Solidity 코드 청크를 확인합니다.

```python
SOL_CODE = """
pragma solidity ^0.8.20; 
contract HelloWorld {  
   function add(uint a, uint b) pure public returns(uint) {
       return a + b;
   }
}
"""

# 분할하고 결과를 출력합니다.
sol_splitter = RecursiveCharacterTextSplitter.from_language(
    language=Language.SOL, chunk_size=128, chunk_overlap=0
)

sol_docs = sol_splitter.create_documents([SOL_CODE])
sol_docs
```

**Output:**

```
[Document(metadata={}, page_content='pragma solidity ^0.8.20;'),
 Document(metadata={}, page_content='contract HelloWorld {  \n   function add(uint a, uint b) pure public returns(uint) {\n       return a + b;\n   }\n}')]
```

## C#

C# 텍스트 분할기를 사용한 예제는 다음과 같습니다.

```python
C_CODE = """
using System;
class Program
{
    static void Main()
    {
        Console.WriteLine("Enter a number (1-5):");
        int input = Convert.ToInt32(Console.ReadLine());
        for (int i = 1; i <= input; i++)
        {
            if (i % 2 == 0)
            {
                Console.WriteLine($"{i} is even.");
            }
            else
            {
                Console.WriteLine($"{i} is odd.");
            }
        }
        Console.WriteLine("Goodbye!");
    }
}
"""

# 분할하고 결과를 출력합니다.
c_splitter = RecursiveCharacterTextSplitter.from_language(
    language=Language.CSHARP, chunk_size=128, chunk_overlap=0
)
c_docs = c_splitter.create_documents([C_CODE])
c_docs
```

**Output:**

```
[Document(metadata={}, page_content='using System;'),
 Document(metadata={}, page_content='class Program\n{\n    static void Main()\n    {\n        Console.WriteLine("Enter a number (1-5):");'),
 Document(metadata={}, page_content='int input = Convert.ToInt32(Console.ReadLine());\n        for (int i = 1; i <= input; i++)\n        {'),
 Document(metadata={}, page_content='if (i % 2 == 0)\n            {\n                Console.WriteLine($\"{i} is even.\");\n            }\n            else'),
 Document(metadata={}, page_content='{\n                Console.WriteLine($\"{i} is odd.\");\n            }\n        }\n        Console.WriteLine(\"Goodbye!\");'),
 Document(metadata={}, page_content='}\n}')]
```
