
# 지난 시간 복습

## Vertex AI - PaaS

- Colab Enterprise: colab이나 colab Pro에 비해 차이점(하드웨어 사양을 우리가 원하는 데로 설정 가능)
- workbench: colab에 비해 장시간 사용하기 위한 서비스 (Presistent Disk boot 100GB, Data 100GB)
- Auto ML - Tabular: 누구를 위한 서비스냐? 인공지능 모델을 모델링하기 어려운, 빠르게 모델링 필요한 경우
- bucket: 구글 클라우드의 저장 공간
- cloud run: 로컬에서 실행하던 환경 그대로 클라우드로 동작

## 클라우드를 사용하는 사람의 목적

1. 개인 서버 없이 서비스를 구현하고 배포하는 목적
2. 인공지능 모델을 개발하고 배포하는 목적
3. 보안 솔루션이나, 안정된 서비스를 활용하는 목적

클라우드 안에 다양한 자격증이 있다.
클라우드 아키텍트 자격증
머신러닝 자격증





# Cloud Run을 사용해서 프로그램 구현하기


## Cloud Run용 실습 예제를 풀 때 사용할 수 있는 두 가지 방법

1. Claude Code로 생성
2. gemini CLI로 생성

## 예전에 비해 얼마나 학습하기가 쉬워졌는가?

가정: 플라스크 새로 스터디 한다.
과거: 플라스크 안내 사이트, 책을 산다. 처음부터 기본을 열심히 읽고 이해하면, 응용부분을 넘어가서 응용(경력)

현재: 생성형AI 활용시 관장 방법
	1. 최소한의 개념만 먼저 이해(개발환경 이해)
	2. 쉬운 코드를 생성해서 동작 시킨다.(쉬운 코드를 분석하고 이해한다.)
		(생성현 코드)
	3. 프롬프트를 구체적으로 묘사하면서 디테일하게 서비스를 구현





**이런 것들을 설치해서 프로그램을 구현한다.**

gemini-cli 설치(Windows, Linux, MacOS)

Calaude Code 설치(Windows cmd X, WSL2를 설치, Linux, MacOS)

Flask, iOS(Xcode, Swift), Android(Android studio, Kotlin)

**프로그램 개발이 이렇게 이루어진다.**

제목: 심플 채팅 앱

1. 로컬PC
	서버: 플라스크(언어 파이썬) PC에서 구동되는 부분
	 클라이언트: 아이디, 텍스트 입력

2. cloud run을 활용해서 GCP에서 구동
	서버: 플라스크 서브 GCP
	 클라이언트는 그대로




## 프로그램 구현하는 과정 순서


Claude Code로 코드 생성하는 방법을 물어보니 이렇게 나옴.


![[1. cloud run 쉬운 예제 1.pdf]]














1. 클론을 해서 github에 있는 채팅 앱을 가져옴

https://github.com/venture21/cloudrun/



![[Pasted image 20250716102945.png]]


2. 내부에 simple_chat가 있는지 확인

![[Pasted image 20250716103036.png]]
이렇게 simple_chat가 있을 것이다.



3. 다음과 명령어 실행

```
(base) C:\Users\SBA\github\cloudrun\simple_chat>gcloud run deploy flask-chat-app --source . --region=asia-northeast3 --allow-unauthenticated
```


![[Pasted image 20250716103603.png]]




`gcloud run deploy flask-chat-app --source . --region=asia-northeast3 --allow-unauthenticated` 명령어는 기본적으로 **배포 명령어**입니다.

하지만 `--source .` 옵션 때문에 **빌드 과정까지 포함**하는 명령어라고 이해하시면 가장 정확합니다.

---

### 명령어 세부 설명

* **`gcloud run deploy`**: 이 명령어 자체가 Cloud Run에 서비스를 배포하라는 핵심 지시입니다.
* **`--source .`**: 이 옵션은 현재 디렉토리(`.`)에 있는 소스 코드를 사용하여 배포하겠다는 의미입니다. Cloud Run은 소스 코드를 직접 실행하지 못하기 때문에, 이 옵션이 있으면 내부적으로 **Google Cloud Build 서비스를 자동 호출**하여 소스 코드를 컨테이너 이미지로 빌드합니다. 이렇게 빌드된 이미지는 **Artifact Registry**에 자동으로 저장됩니다.
* **`flask-chat-app`**: Cloud Run에 배포될 서비스의 이름입니다.
* **`--region=asia-northeast3`**: 서비스가 배포될 GCP 리전(예: 서울)을 지정합니다.
* **`--allow-unauthenticated`**: 이 옵션은 인증되지 않은 사용자도 배포된 Cloud Run 서비스에 접근할 수 있도록 허용합니다. (즉, 공개적으로 접근 가능하게 만듭니다.)

---

### 결론

이 명령어는 다음 세 가지 주요 단계를 한 번에 처리해주는 편리한 명령어입니다.

1.  **빌드**: 현재 소스 코드를 기반으로 컨테이너 이미지를 빌드합니다.
2.  **저장**: 빌드된 이미지를 Artifact Registry에 저장합니다.
3.  **배포**: 저장된 컨테이너 이미지를 Cloud Run 서비스로 배포하고 실행합니다.







4. 권한 문제 해결하기

![[Pasted image 20250716104000.png]]

그런데 위와 같이 권한 문제가 뜬다.



5. 그러면 다음 명령어로 권한을 부여한다.
```
(base) C:\Users\SBA\github\cloudrun\simple_chat>gcloud services enable cloudbuild.googleapis.com

(base) C:\Users\SBA\github\cloudrun\simple_chat>gcloud services enable run.googleapis.com

(base) C:\Users\SBA\github\cloudrun\simple_chat>gcloud services enable artifactregistry.googleapis.com

(base) C:\Users\SBA\github\cloudrun\simple_chat>gcloud services enable containerregistry.googleapis.com  
```

![[Pasted image 20250716105330.png]]

필요한 API 활성화:  
  
  # Cloud Build API  
  gcloud services enable [cloudbuild.googleapis.com](http://cloudbuild.googleapis.com)  
  
  # Cloud Run API  
  gcloud services enable [run.googleapis.com](http://run.googleapis.com)  
  
  # Artifact Registry API  
  gcloud services enable [artifactregistry.googleapis.com](http://artifactregistry.googleapis.com)  
  
  # Container Registry API (필요한 경우)  
  gcloud services enable [containerregistry.googleapis.com](http://containerregistry.googleapis.com)





6. 권한 부여 후 다시 배포할 때 확실히 하려면 내 프로젝트에 올라가 있는 Artifact Registry와 Cloud Run을 삭제해야 한다.

**Artifact Registry 삭제**

![[Pasted image 20250716112557.png]]




**Cloud Run 삭제**
![[Pasted image 20250716112640.png]]




### Artifact Registry와 Cloud Run의 역할

---

* **Artifact Registry (컨테이너 이미지 저장소)**
    * **"컨테이너가 만들어지는 곳"** 이라는 표현보다는, **빌드된 컨테이너 이미지를 저장하고 관리하는 중앙 레지스트리** 역할을 합니다.
    * 개발자가 작성한 코드와 Dockerfile을 사용하여 컨테이너 이미지를 빌드하면, 이 완성된 이미지는 Artifact Registry에 **푸시(저장)**됩니다.
    * 단순히 Docker 이미지뿐만 아니라, Maven, npm, Python 패키지 등 다양한 소프트웨어 아티팩트를 저장할 수 있는 통합 저장소입니다.

* **Cloud Run (컨테이너 서비스 배포 및 실행 플랫폼)**
    * **"여기에서 배포가 된다."** 는 정확한 설명입니다. Cloud Run은 Artifact Registry에 저장된 컨테이너 이미지를 가져와 **실제로 실행 가능한 서비스로 배포하고 관리하는 서버리스 플랫폼**입니다.
    * Cloud Run은 배포된 컨테이너를 자동으로 확장하고(수요에 따라 인스턴스 수 조절), 트래픽 라우팅, 버전 관리 등을 처리하여 개발자가 인프라 관리에 신경 쓰지 않고 코드 작성에만 집중할 수 있도록 돕습니다.

---

### 배포 과정 요약

1.  **이미지 빌드**: 개발자가 작성한 코드와 Dockerfile을 사용하여 컨테이너 이미지를 빌드합니다. (이 과정은 보통 Cloud Build와 같은 CI/CD 서비스나 로컬 환경에서 수행됩니다.)
2.  **이미지 저장**: 빌드된 **컨테이너 이미지**는 **Artifact Registry**에 안전하게 **저장**됩니다.
3.  **서비스 배포 및 실행**: **Cloud Run**은 Artifact Registry에 있는 해당 이미지를 가져와 실제 **서비스로 배포하고 실행**합니다. 사용자의 요청이 오면 이 서비스가 응답합니다.











4. 그 후 다시 다음 명령어 입력

```
gcloud run deploy flask-chat-app --source . --region=asia-northeast3 --allow-unauthenticated
```



![[Pasted image 20250716130711.png]]
위 이미지와 같이 배포가 되면서 해당 URL로 들어가면 간단한 채팅 앱을 사용해 볼 수 있다.

또한 GCP의 Artifact Registry와 Cloud Run에 올라가 있다.





## GCP의 IAM

GCP의 IAM (Identity and Access Management)은 Google Cloud Platform에서 **누가(Who)** 어떤 리소스에 대해(On which resource) **무엇을 할 수 있는지(What Role)**를 세밀하게 제어할 수 있도록 돕는 핵심 보안 기능입니다. 쉽게 말해, GCP의 모든 서비스와 리소스에 대한 접근 권한을 관리하는 시스템이라고 생각하시면 됩니다.

### IAM의 세 가지 주요 구성 요소:

1.  **주 구성원 (Principal / Member):**
    * 권한을 부여받는 사람 또는 시스템의 ID를 의미합니다.
    * 다음과 같은 유형이 있습니다:
        * **Google 계정**: 일반적인 사용자 (예: Gmail 계정)
        * **서비스 계정**: 애플리케이션이나 가상 머신이 GCP 리소스에 접근할 때 사용하는 특수 계정. 사용자 자격 증명 없이도 안전하게 접근할 수 있어 자동화 및 통합에 유용합니다.
        * **Google 그룹**: 여러 사용자를 하나의 그룹으로 묶어 권한을 부여할 수 있습니다.
        * **G Suite 도메인**: G Suite를 사용하는 조직 전체에 권한을 부여할 수 있습니다.
        * **모든 사용자(allUsers) / 모든 인증된 사용자(allAuthenticatedUsers)**: 공개적인 접근을 허용할 때 사용됩니다.

2.  **역할 (Role):**
    * 주 구성원에게 부여하려는 권한들의 모음입니다. 개별 권한을 하나씩 부여하는 대신, 특정 작업을 수행하는 데 필요한 권한들을 역할로 묶어 부여합니다.
    * 역할에는 세 가지 주요 유형이 있습니다:
        * **사전 정의된 역할 (Predefined Roles)**: Google Cloud 서비스에서 관리하며, 각 서비스에 대해 일반적인 작업을 수행하는 데 필요한 권한을 포함합니다. 예를 들어 `roles/storage.viewer`는 Cloud Storage 버킷의 내용을 볼 수 있는 권한을 제공합니다.
        * **커스텀 역할 (Custom Roles)**: 사용자가 직접 만들고 권한을 지정하는 역할입니다. 특정 요구사항에 맞춰 세밀하게 권한을 제어할 수 있지만, 유지보수 부담이 더 큽니다.
        * **기본 역할 (Basic Roles)**: `소유자(Owner)`, `편집자(Editor)`, `뷰어(Viewer)`와 같이 광범위한 접근 권한을 제공하는 역할입니다. 테스트 목적에는 유용할 수 있지만, 프로덕션 환경에서는 **최소 권한 원칙**에 따라 사용을 지양하는 것이 좋습니다.

3.  **리소스 (Resource):**
    * 주 구성원이 접근하도록 허용하려는 Google Cloud 내의 모든 자산입니다. (예: Compute Engine 인스턴스, Cloud Storage 버킷, BigQuery 데이터세트 등)




PC에서 google cloud run을 통해서 배포를 할 경우에는 이메일이 필요하고(내부로 진입하는데 필요한 이메일이 필요) 
GCP에서 사용할 경우에는 '역학' 권할이 필요하다.

### 1. PC에서 Google Cloud Run 배포 시 '이메일' (내부 진입에 필요한 이메일)

정확한 표현은 '**서비스 계정**'입니다. PC에서 `gcloud` CLI 등을 사용하여 Cloud Run에 배포할 때, 실제로 배포 작업을 수행하는 주체는 사용자 계정(Google 계정)이거나, 더 일반적으로는 **서비스 계정(Service Account)**입니다. 이 서비스 계정은 Cloud Run에 배포할 수 있는 권한을 가지고 있어야 합니다. 예를 들어, Cloud Build를 통해 배포하는 경우 Cloud Build 서비스 계정이 Cloud Run에 배포할 수 있는 권한(예: `Cloud Run 관리자` 역할)을 가지고 있어야 합니다.

"내부로 진입하는데 필요한 이메일"이라는 표현은 아마도 Cloud Run 서비스가 배포된 후, 해당 서비스에 접근할 때 인증된 사용자(특정 이메일 주소를 가진 Google 계정)만 접근하도록 설정하는 경우를 말씀하시는 것 같습니다. Cloud Run 서비스는 기본적으로 공개 접근이 허용되지만, `--no-allow-unauthenticated` 옵션을 사용하여 비인증 접근을 막고 특정 IAM 주 구성원(Google 계정, 서비스 계정, Google 그룹 등)만 호출할 수 있도록 설정할 수 있습니다. 이때 해당 주 구성원의 이메일 주소가 필요합니다.

---

### 2. GCP에서 사용할 경우 '역할' 권한

이것은 정확합니다. GCP의 IAM은 "누가(Who) 어떤 리소스에 대해 **무엇을 할 수 있는지(What Role)**"를 제어하는 시스템이므로, Cloud Run을 사용하려면 적절한 **IAM 역할(Role)**이 필요합니다.

Cloud Run과 관련된 주요 역할은 다음과 같습니다:

* **Cloud Run 관리자 (`roles/run.admin`)**: Cloud Run 서비스 및 작업을 생성, 업데이트, 삭제하는 등 모든 관리 권한을 가집니다. 배포를 수행하는 주체(예: 사용자 또는 서비스 계정)에게 필요한 역할입니다.
* **Cloud Run 호출자 (`roles/run.invoker`)**: 배포된 Cloud Run 서비스를 호출(실행)할 수 있는 권한을 가집니다. 서비스에 접근하려는 사용자나 다른 서비스에 부여하는 역할입니다.
* **서비스 계정 사용자 (`roles/iam.serviceAccountUser`)**: Cloud Run 서비스가 특정 서비스 계정을 사용하여 실행될 때, 해당 서비스 계정을 "대신하여" 작업을 수행할 수 있도록 해주는 역할입니다.

---

### 정리하자면,

* **배포 시**: 배포를 수행하는 주체(사용자 계정 또는 서비스 계정)는 `Cloud Run 관리자`와 같은 적절한 IAM 역할이 필요합니다.
* **서비스 접근 시**: 배포된 Cloud Run 서비스에 접근하는 주체(사용자 또는 다른 서비스)는 `Cloud Run 호출자`와 같은 적절한 IAM 역할이 필요합니다. 만약 서비스가 비인증 접근을 허용하지 않는다면, 접근하려는 주체의 이메일 주소(Google 계정 또는 서비스 계정)가 해당 `Cloud Run 호출자` 역할에 추가되어야 합니다.







## gemini-cli 이용해서 프로그램을 직접 만든 후 배포

gemini를 이용해서 프로그램을 작성한 후 다시 한번 배포 해보자.

사용한 프롬프트

```
플라스크로 간단한 채팅앱 만들어줘

방금 생성했던 코드를 GCP의 cloud run에서 실행할 수 있게 해줘.
```

그 후 gemini-cli를 종료한 후 다음 명령어를 이전처럼 실행해서 배포한다.

`gcloud run deploy flask-chat-app --source . --region=asia-northeast3 --allow-unauthenticated`









claude code로 만든 것과 gemini로 만들 것을 비교해보면 UI 등의 부분해서 퀄리티 차이가 난다. claude code가 더 코드적으로 더 구체적으로 더 예쁘게 나온다. 아직까지는 말이다.








## ToDoList 만들기

사용 프롬프트

```
To Do List를 작성하고 관리할 수 있는 웹앱을 플라스크로 만들고 싶은데 어떤 기능과 어떤 방식으로 인터페이스를 구성할 지 알려줘.


아래와 같이 가장 기본 적인 기능부터 구현을 하고 싶어.  
-아래  
1. 할 일 추가 (Add Task): 사용자가 새로운 할 일을 텍스트로 입력하고 목록에 추가할 수 있습니다.  
2. 할 일 목록 조회 (View Tasks): 현재 등록된 모든 할 일 목록을 보여줍니다.  
3. 할 일 완료 처리 (Complete Task): 할 일을 완료 상태로 변경합니다. 완료된 항목은 시각적으로 구분(예: 취소선)해 줍니다.  
4. 할 일 삭제 (Delete Task): 목록에서 할 일을 영구적으로 제거합니다.


현재 코드에서 입력된 일정을 수정하는 기능을 수정해줘


현재 진행 중인 프로젝트를 잠시 멈추고 다른 신규 프로젝트를 만들려고 하는데 현재 상태를 다음에 이어서 진행할 수 있도록 저장해줘.

To Do List 웹앱을 만들고 싶은데 어떻게 기획을 할지 알려줘.

현재 프로젝트는 종료하고 이전에 저장했던 프로젝트를 이어서 진행할께

현재 폴더의 생성된 파일을 다시 한번 확인하고 이 파일을 이용해서 cloud run에 배포할 수 있게 해줘. 배포시에는 gcloud run deploy flask-chat-app --source . --region=asia-northeast3 --allow-unauthenticated 명령어로 진행할 수 있게 해줘.

현재 워킹 디렉토리에 UI.png 파일을 참조해서 인터페이스를 변경해줘
```





## 챗봇


```python
from google import genai

from google.genai import types

import base64

  

def generate():

  client = genai.Client(

      vertexai=True,

      project="sesac-ericyum9196",

      location="global",

  )

  
  

  model = "gemini-2.5-flash"

  contents = [

    types.Content(

      role="user",

      parts=[

      ]

    )

  ]

  

  generate_content_config = types.GenerateContentConfig(

    temperature = 1,

    top_p = 1,

    seed = 0,

    max_output_tokens = 65535,

    safety_settings = [types.SafetySetting(

      category="HARM_CATEGORY_HATE_SPEECH",

      threshold="OFF"

    ),types.SafetySetting(

      category="HARM_CATEGORY_DANGEROUS_CONTENT",

      threshold="OFF"

    ),types.SafetySetting(

      category="HARM_CATEGORY_SEXUALLY_EXPLICIT",

      threshold="OFF"

    ),types.SafetySetting(

      category="HARM_CATEGORY_HARASSMENT",

      threshold="OFF"

    )],

    thinking_config=types.ThinkingConfig(

      thinking_budget=-1,

    ),

  )

  

  for chunk in client.models.generate_content_stream(

    model = model,

    contents = contents,

    config = generate_content_config,

    ):

    print(chunk.text, end="")

  

generate()
```

```
위 코드를 토대로 해서 챗봇 앱을 만들어줘

`gcloud run deploy flask-chat-app --source . --region=asia-northeast3 --allow-unauthenticated`
위 명령어로 GCP를 통해 배포를 해줘
```


