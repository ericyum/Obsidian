# Secret Manager를 이용해서 API KEY값 가져오기

GCP의 보안 -> Secret Manager를 배울 것이다.

![[Pasted image 20250718092514.png]]


1. 보안 비밀 만들기 클릭

![[Pasted image 20250718092847.png]]

2. 빈 칸 입력하기. 특히 비밀 값이 API KEY값을 넣기

![[Pasted image 20250718092928.png]]

3. 그럼 아래와 같이 비밀이 하나 생긴다. 이것을 Colab Enterprise 같은 곳이나 PC에서 Cloud Run을 이용해서 사용할 수 있다. 한 마디로 '등록'을 한 것이다.

4. 이제 myGemini를 배포 한다.

```
(gemini) C:\Users\SBA\github\cloudrun2\cloudrun\myGemini> gcloud run deploy mygemini --source . --region asia-northeast3 --platform managed --allow-unauthenticated --set-secrets="GOOGLE_API_KEY=GOOGLE_API_KEY:latest"
```

기존에는 직업 API KEY를 입력했는데 이번에는 secret manager를 통해서 API KEY를 얻는다.

참고) 내 계정에 secret manager를 사용할 수 있는 권한이 없으면 접근 권한이 없다며 에러가 뜬다. 그럴 경우에는 권한을 편집할 수 있는 상급 편집자가 나에게 권한을 부여해야 한다.

![[Pasted image 20250718100455.png]]

# Colab Enterprise에서 활용하기

```
!pip install google-cloud-secret-manager
```

``` python
from google.cloud import secretmanager

import os

  

def access_secret(project_id, secret_name):

    """

    Google Cloud Secret Manager에서 보안 비밀에 접근합니다.

  

    Args:

        project_id (str): Google Cloud 프로젝트 ID.

        secret_name (str): Secret Manager에 저장된 보안 비밀의 이름.

  

    Returns:

        str: 디코딩된 보안 비밀 값.

    """

  

    # 보안 비밀의 전체 리소스 경로 구성

    secret_resource_name = f"projects/{project_id}/secrets/{secret_name}/versions/latest"

  

    # Secret Manager 클라이언트 생성

    client = secretmanager.SecretManagerServiceClient()

  

    # 보안 비밀 버전 접근

    response = client.access_secret_version(name=secret_resource_name)

  

    # 보안 비밀 값 디코딩 및 반환

    secret_value = response.payload.data.decode("UTF-8")

    return secret_value

  

# 사용 예시:

PROJECT_ID = "sesac-ericyum9196"

SECRET_NAME = "GOOGLE_API_KEY"

  

secret = access_secret(PROJECT_ID, SECRET_NAME)

#secret
```













**전체 코드를 생성하는 생성형(Agent)**
Gemini-CLI (GCP의 최신 모델을 몰라...)
Claude Code(gemini 2.0까지만 알고 있다)

**GCP안에 Cloud Assist**
이 기능으로 Imagen4, Veo3와 같은 최신 모델은
여기서 코드를 생성하고 Colab Enterprise에서 테스트하자.
Vertex 라이브러리를 사용할 경우에는 Colab Enterprise가 편하다. (권한설정부분)







# Media Studio Colab에서 열기



# Imagen4의 이미지 생성 기능

```
!pip install --upgrade --user google-cloud-aiplatform
```

이미지를 보여주는 메서드 생성
```python
import typing

import IPython.display

from PIL import Image as PIL_Image

from PIL import ImageOps as PIL_ImageOps

  

def display_image(

    image,

    max_width: int = 600,

    max_height: int = 350,

) -> None:

    pil_image = typing.cast(PIL_Image.Image, image._pil_image)

    if pil_image.mode != "RGB":

        # RGB is supported by all Jupyter environments (e.g. RGBA is not yet)

        pil_image = pil_image.convert("RGB")

    image_width, image_height = pil_image.size

    if max_width < image_width or max_height < image_height:

        # Resize to display a smaller notebook image

        pil_image = PIL_ImageOps.contain(pil_image, (max_width, max_height))

    IPython.display.display(pil_image)
```

실제로 텍스트를 입력해서 이미지 생성하기
```python
from vertexai.preview.vision_models import ImageGenerationModel

import vertexai

  

vertexai.init(project="sesac-ericyum9196", location="us-central1")

  

generation_model = ImageGenerationModel.from_pretrained("imagen-4.0-generate-preview-06-06")

  

# 사용자로부터 프롬프트 입력 받기

prompt = input("Enter your prompt: ")

  

images = generation_model.generate_images(

    prompt=prompt,

    number_of_images=4,

    aspect_ratio="1:1",

    negative_prompt="",

    person_generation="allow_all",

    safety_filter_level="block_few",

    add_watermark=True,

)

  

display_image(images[0])
```


## Chirp3의 음성 변환 기능

한국어 음성에는 뭐뭐가 있는지 확인
``` python
import google.auth

import google.auth.transport.requests

import requests

  

def list_supported_voices_ko():

    """

    Text-to-Speech API에서 지원하는 한국어 음성 목록만 가져옵니다.

    """

    credentials, project_id = google.auth.default()

    request_auth = google.auth.transport.requests.Request()

    credentials.refresh(request_auth)

    access_token = credentials.token

  

    url = "https://texttospeech.googleapis.com/v1/voices?languageCode=ko-KR"  # 한국어 코드 지정

    headers = {

        "X-Goog-User-Project": project_id,

        "Authorization": f"Bearer {access_token}"

    }

  

    try:

        response = requests.get(url, headers=headers)

        response.raise_for_status()

        voices = response.json()['voices']

        return voices

    except requests.exceptions.RequestException as e:

        print(f"API 호출 중 오류 발생: {e}")

        return None

  

voices_ko = list_supported_voices_ko()

if voices_ko:

    for voice in voices_ko:

        print(f"언어 코드: {voice['languageCodes']}, 음성 이름: {voice['name']}")
```

음성 선택
``` python
import ipywidgets as widgets

from IPython.display import display

  

def create_voice_selection_widgets_ko(voices):

    """

    사용 가능한 한국어 음성 목록을 기반으로 음성 선택 드롭다운 목록을 생성합니다.

    """

    # 한국어 음성만 필터링

    korean_voices = [voice for voice in voices if voice['languageCodes'][0] == 'ko-KR']

  

    voice_name_dropdown = widgets.Dropdown(

        options=[voice['name'] for voice in korean_voices],

        description='음성:',

        disabled=False,

    )

  

    display(voice_name_dropdown)

    return voice_name_dropdown

  

# voices 변수가 이미 정의되어 있다고 가정합니다.

voice_name_dropdown_ko = create_voice_selection_widgets_ko(voices_ko)
```

텍스트를 입력 받고 구동하기
``` python
import google.auth

import google.auth.transport.requests

import json

import requests

import base64 # 오디오 파일 저장에 필요

  

def synthesize_text_to_speech_from_input():

    """

    Google Cloud Text-to-Speech API를 사용하여 사용자 입력 텍스트를 음성으로 합성합니다.

    """

    # 1. 사용자로부터 텍스트 입력 받기

    user_text = input("음성으로 변환할 텍스트를 입력하세요: ")

    if not user_text:

        print("텍스트가 입력되지 않았습니다. 프로그램을 종료합니다.")

        return

  

    # 2. 인증 정보 가져오기

    credentials, project_id = google.auth.default()

  

    # 인증 요청 객체 생성

    request_auth = google.auth.transport.requests.Request()

    credentials.refresh(request_auth) # 인증 정보 갱신 (필요한 경우)

  

    access_token = credentials.token

  

    # 3. API 엔드포인트 및 헤더 설정

    url = "https://texttospeech.googleapis.com/v1/text:synthesize"

    headers = {

        "Content-Type": "application/json",

        "X-Goog-User-Project": project_id,

        "Authorization": f"Bearer {access_token}"

    }

  

    # 4. 요청 본문(Payload) 설정

    payload = {

        "input": {

            "text": user_text  # 사용자로부터 입력받은 텍스트 적용

        },

        "voice": {

            "languageCode": "ko-KR",

            "name": "ko-KR-Chirp3-HD-Achernar",

            "voiceClone": {}

        },

        "audioConfig": {

            "audioEncoding": "LINEAR16"

        }

    }

  

    # 5. API 호출

    response = None # 초기화

    try:

        print(f"'{user_text}' 텍스트를 음성으로 합성 중...")

        response = requests.post(url, headers=headers, data=json.dumps(payload))

        response.raise_for_status()  # HTTP 오류 발생 시 예외 발생

  

        # 6. 응답 처리

        response_data = response.json()

        audio_content_base64 = response_data['audioContent']

  

        audio_data = base64.b64decode(audio_content_base64)

  

        output_filename = "output.wav"

        with open(output_filename, "wb") as out_file:

            out_file.write(audio_data)

            print(f"오디오 콘텐츠가 '{output_filename}' 파일로 저장되었습니다.")

  

    except requests.exceptions.RequestException as e:

        print(f"API 호출 중 오류 발생: {e}")

        if response is not None:

            print(f"응답 상태 코드: {response.status_code}")

            print(f"응답 본문: {response.text}")

    except Exception as e:

        print(f"예기치 않은 오류 발생: {e}")

  

if __name__ == "__main__":

    synthesize_text_to_speech_from_input()
```


# Veo3의 영상 생성 기능

Veo3 같은 곳에서 코드 가져오기를 하면 python이 아닌 다른 언어로 되어있다. 그런데 나는 python 환경에서 돌리고 싶다. 그래서 Cloud Assist에서 python으로 변경해달라고 요청을 보냈다.

``` python
import google.auth
import google.auth.transport.requests
import json
import os

def generate_veo_video(project_id: str, location: str, prompt: str):
    """
    Generates a video using the Veo 3.0 model.

    Args:
        project_id: Your Google Cloud project ID.
        location: The Google Cloud region (e.g., 'us-central1').
        prompt: The text prompt for video generation.

    Returns:
        The operation ID for the long-running video generation task.
    """
    
    API_ENDPOINT = f"{location}-aiplatform.googleapis.com"
    MODEL_ID = "veo-3.0-generate-preview"

    # Authenticate with Google Cloud
    credentials, project = google.auth.default(scopes=['https://www.googleapis.com/auth/cloud-platform'])
    auth_req = google.auth.transport.requests.Request()
    credentials.refresh(auth_req)
    access_token = credentials.token

    # Define the request payload
    request_payload = {
        "endpoint": f"projects/{project_id}/locations/{location}/publishers/google/models/{MODEL_ID}",
        "instances": [
            {
                "prompt": prompt,
            }
        ],
        "parameters": {
            "aspectRatio": "16:9",
            "sampleCount": 2,
            "durationSeconds": "8",
            "personGeneration": "allow_all",
            "addWatermark": True,
            "includeRaiReason": True,
            "generateAudio": True,
        }
    }

    # Construct the API URL
    url = (
        f"https://{API_ENDPOINT}/v1/projects/{project_id}/locations/{location}/"
        f"publishers/google/models/{MODEL_ID}:predictLongRunning"
    )

    # Set up headers
    headers = {
        "Content-Type": "application/json",
        "Authorization": f"Bearer {access_token}",
    }

    # Make the HTTP POST request
    response = auth_req.post(url, headers=headers, data=json.dumps(request_payload))
    response.raise_for_status()  # Raise an exception for bad status codes

    response_json = response.json()
    operation_id = response_json.get("name")

    return operation_id

if __name__ == "__main__":
    PROJECT_ID = "sesac-ericyum9196"
    LOCATION_ID = "us-central1"
    USER_PROMPT = "A futuristic city at sunset with flying cars." # Replace with your desired prompt

    try:
        operation_id = generate_veo_video(PROJECT_ID, LOCATION_ID, USER_PROMPT)
        print(f"OPERATION_ID: {operation_id}")
    except Exception as e:
        print(f"An error occurred: {e}")
```

이렇게 필요에 따라 한 쪽 언어에서 다른 쪽 언어로 변경할 수 있다.

**하지만 권한 문제 때문에 python에서는 실행 할 수 없는 것으로 보인다. 그냥 콘솔에서 실행하는 curl 형태에서 실행을 하자.**